const WRITING_SAMPLES = [{"lines":[{"text":"This weekend, on September 10, 2016, the Defcon Toronto Meetup group hosted their"},{"text":"first ever CTF!  I was able to put together a team including myself, my friend"},{"text":"David, and Anna, someone who happened to be broadcasting their interest in the CTF"},{"text":"via the group's Slack channel (and doesn't have Twitter). David himself is actually"},{"text":"heavily involved in Carleton University's CTF team, however neither I nor Anna"},{"text":"have participated in a CTF before, though both of us have done some web appsec challenges."},{"text":"The whole event took place over the course of eight hours which my team spent"},{"text":"frantically searching for clues and finding flags.  It is obvious in our unorthodox"},{"text":"approaches to things that neither Anna nor I had partaken in a CTF before, but"},{"text":"fortunately David had some familiarity with enough tools to get us through some"},{"text":"trickier challenges."},{"text":""},{"text":"Despite all of our fumbling, my team actually managed to come out in first place!"},{"text":"We had a great time and were competing down to the wire to come out ahead."},{"text":"I'll post a link to David's writeup when he gets to it, as well as Anna's if"},{"text":"she writes one, but for now I'll write about the challenges I can recall in detail."},{"text":""}]},{"lines":[{"text":"Right before we submitted the 10th flag, we were right behind the VulnHub team,"},{"text":"who we'd been competing toe-to-toe with for the duration of the event. With"},{"text":"just a few seconds remaining we had managed to submit the 10th flag and pull into the lead."},{"text":"This whole event was a lot of fun and incredibly exciting. My two excellent teammates,"},{"text":"Anna and Dave, stuck with me for the entire eight hours, and there's no way we would"},{"text":"have have done anywhere near as well as we did without their help.  I had no expectations"},{"text":"of doing as well as we did, given that this was my first time participating, but it was"},{"text":"a great deal of fun and I'm looking forward to doing more in the future."},{"text":"The Defcon Toronto group is a pretty young one, having only been around for about four"},{"text":"months, but it's already one of my favorites in the city. I want to say thanks to the"},{"text":"entire DC416 crew for putting these challenges together and to everyone that"},{"text":"participated for the great competition!"},{"text":""}]},{"lines":[{"text":"As a subject for further research, one might investigate the potential to frame"},{"text":"finite state transducers in the framework of the kind of transducer we have"},{"text":"explored in this paper. It is my suspicion that one could implement transition"},{"text":"relations in terms of reducing functions quite naturally. In particular, we can"},{"text":"see how a simple transition such as (q1, a:b, q2) could be implemented as a"},{"text":"mapping that accepts the value [(a, q1)] and returns [(b, q2)]. Similarly, a"},{"text":"transition such as (q1, a:E, q2) that deletes the character 'a' could be"},{"text":"implemented as a filtering. A non-deterministic FST that allows for multiple"},{"text":"transitions with the same upper or lower string would just be a flatmapping,"},{"text":"or a flatmapping composed with a filtering if epsilon transitions are allowed."},{"text":"It may even be possible to implement FSTs simply by returning to the formal"},{"text":"definition we saw earlier. In this construction, we would be able to implement"},{"text":"the set of transition relations as one composed transducer. However, because"},{"text":"this approach would result in a single entity- the composed transducer- that,"},{"text":"based on what I've read so far, I do not believe would be possible to decompose"},{"text":"for FST operations such as composition. However, it may be possible to implement"},{"text":"operations such as intersection and union very simply using transducer"},{"text":"composition. The exact details of how these operations on finite state"},{"text":"transducers could be implemented would need to be explored but, because we are"},{"text":"working with an abstraction of the fold function we saw much earlier, we would"},{"text":"have a powerful foundation to reason formally about our constructions and both"},{"text":"investigate and prove their properties."},{"text":"Transducers provide us with a new way to think about problems that can be"},{"text":"formalized as a fold. Interestingly, a finite state transducer expressed as a"},{"text":"transducer would require no more space to store than the transducer itself,"},{"text":"which is simply a function. We would not be required to create a graph data"},{"text":"structure to represent the FST, which would clearly mean saving an incredible"},{"text":"amount of memory. An interesting observation is that, due to our choice of the"},{"text":"[Integer] type to represent states, the composition of two simple FSTs with"},{"text":"states such as [1] and [2] would have states [1, 1], [1, 2], [2, 1], and"},{"text":"[2, 2]. This means that the composed transition relations would have to be"},{"text":"constructed to perform no operations on states with only one identifier, and"},{"text":"only transition on states containing two identifiers. In this sort of"},{"text":"construction, the complexity of our transducer would grow, but it would be"},{"text":"rather simple to create a composed FST by composing a transducer that performs"},{"text":"these composed operations onto either of the original FSTs- or, perhaps, their"},{"text":"composition. Clearly, there is a great deal to consider in working to formulate"},{"text":"FSTs as transducers, however these thoughts lead me to believe that there may"},{"text":"in fact be a number of interesting properties to be discovered with regards"},{"text":"to FSTs represented as transducers."},{"text":""}]},{"lines":[{"text":"A lot of the Rust code you are likely to find yourself writing will involve"},{"text":"functions that return a Result. This will especially be the case when you"},{"text":"are building or working with a library.  In the majority of those cases,"},{"text":"you're going to want to be performing transformations on the value contained"},{"text":"within a Result's Ok variant, or else return the first Err you encounter,"},{"text":"converted into the Error type that your codebase abstracts errors under."},{"text":"In those cases, you should prefer the ? syntax for its elegance.  Of course,"},{"text":"the other means of handling errors cannot be neglected.  They still have"},{"text":"their place.  Perhaps you want to perform some transformation on the value"},{"text":"contained in an Ok but don't want to have to store the intermediate value."},{"text":"In that case, it's probably most elegant to write the following."},{"text":"let modified_value = do_some_thing().map(safely_manipulate)?;"},{"text":"Moreover, when you're implementing an application, your main function in"},{"text":"particular is probably going to want to completely deconstruct the contents"},{"text":"of some Result, since it certainly isn't going to propagate an error.  For"},{"text":"example, while you might have a function to load a configuration file into"},{"text":"a Config struct that you've defined which will propagate any errors it"},{"text":"encounters, your main function would probably want to check for an error"},{"text":"and terminate the program if one occurred."},{"text":"I hope that this post has been effective at introducing you to the most"},{"text":"common ways to handle/propagate errors in Rust.  The language features"},{"text":"so many ways to deconstruct or else propagate Results precisely because"},{"text":"there are so many ways that someone may want to address a potentially"},{"text":"failed operation. It is very much worth your time to understand how pattern"},{"text":"matching can be helpful to you, since both match and if let are useful for"},{"text":"much more than just deconstructing errors. Likewise, it is worth your"},{"text":"energy to try to design abstractions that propagate errors, and to"},{"text":"understand when you should use the new ? syntax and when you might want"},{"text":"to use Result.and_then, Result.map, Result.map_err and similar methods."},{"text":"Finally, there is an excellent section in the Rust book on the subject of"},{"text":"error handling, which goes into a lot more detail about some of the things"},{"text":"I alluded to here.  You should familiarize yourself with the content present"},{"text":"there and may wish to return to this post until you find a style that works"},{"text":"for you in the kinds of situations you deal with when writing Rust code."},{"text":""}]},{"lines":[{"text":"Let us now consider finite state transducers, which we are already familiar"},{"text":"with from the field of natural language processing. Formally, a finite"},{"text":"state transducer is defined as a six-tuple containing a set of states, an"},{"text":"input alphabet, an output alphabet, a set of starting states, a set of final"},{"text":"states, and a set of relations between states and members of the input alphabet"},{"text":"to pairs of a state and members of the output alphabet. In Haskell, we might"},{"text":"directly model such a structure with some type synonyms and a data type."},{"text":""}]},{"lines":[{"text":"Here, we are supposing that our imaginary APIError implements the std::convert::From"},{"text":"trait in such a way  that we can convert from either an HTTP request error, a"},{"text":"response reading error, or a JSON decode error into APIError."},{"text":"Hopefully it is relatively clear that what this code is doing is, after setting"},{"text":"up an HTTP client and the endpoint URL string, it sends an HTTP GET request and"},{"text":"then attempts to read the response's body before parsing it, treating it as JSON,"},{"text":"into an Address struct.  Because we are method chaining on the Result type, we"},{"text":"never actually stop working with a Result. That means, at the end of the sequence"},{"text":"of method invocation, we can simply return the final Result instance, after having"},{"text":"applied any appropriate closures (supplied to and_then, map, and map_err)."},{"text":"This approach felt, to me, anyway, like the best way to do things after having"},{"text":"written a lot of backend Javascript using Promises.  The approach is sufficiently"},{"text":"effective to handle all of the variants a Result can take, and even lets us fairly"},{"text":"elegantly (i.e. without unwrapping) chain operations on each variant using Rust's"},{"text":"closures. However, with regards to elegance, code written in this style can quickly"},{"text":"become quite unappealing and hard to deal with as we indent several times in order"},{"text":"to apply operations to intermediate results (such as that of response.read_to_string)"},{"text":"in order to maintain a consistent Result type. Note that get_location_info must"},{"text":"return an APIError in its Err variant, so we must invoke Result.map_err in order"},{"text":"to do type conversions, and use Result.map to ignore an unwanted intermediate"},{"text":"value in favor of another (in our case, the body of a response, rather than the"},{"text":"success result of having read it).  This approach also suffers from an unfortunate"},{"text":"functional failure in that it makes our code difficult to refactor.  Suppose we"},{"text":"wanted to not just return an Address in the Ok variant, but perhaps also the"},{"text":"response's status code?  I'll leave it as an exercise to the reader to figure"},{"text":"out how we'd do that."},{"text":"The use of method chaining is perhaps best left to shorter transformations where"},{"text":"we might not mind losing information between each chained transformation."},{"text":""}]},{"lines":[{"text":"To begin our discussion, let us first address the question of what functional"},{"text":"programming is. While fractions of the functional programming community have"},{"text":"not reached total consensus with regards to exactly what attributes uniquely"},{"text":"define the field, there are a few key traits that are widely accepted. First"},{"text":"is the focus on and support for higher-order and first class functions, which"},{"text":"accept other functions as parameters and can return functions. Second is the"},{"text":"focus on purity. The phrase referential transparency is often used here to"},{"text":"describe the feature that functions do not have side-effects and will always"},{"text":"return the same result when called on the same input, giving them the property"},{"text":"of being much more like functions of the mathematical variety. A third"},{"text":"attribute of the functional style is that recursion is preferred to iteration."},{"text":"We will see that recursive functions can embody all of the functionality of"},{"text":"iterative functions and that a particular variety of recursive functions-"},{"text":"namely, folds- have some very powerful properties. Functional programs also"},{"text":"tend to be written in a declarative style rather than an imperative one."},{"text":"This means that, rather than writing code that tells the computer exactly how"},{"text":"to compute something, our functions describe what it is that is to be computed."},{"text":"Functional programming also encourages the separation of functionality from"},{"text":"data- quite the opposite of object-oriented languages that encourage the"},{"text":"notion that the two should be combined. As a result of this property, it is"},{"text":"often said that everything in a functional programming language is a value."},{"text":"This statement is critical to our understanding of the role functions play in"},{"text":"programs, as functions are themselves values subject to being operated on with"},{"text":"operations such as composition. Functional programming languages also often"},{"text":"feature powerful type systems, such as that of Haskell, but can"},{"text":"be dynamically typed as Clojure is."},{"text":"In our first case study, we will have a look at the incredibly important"},{"text":"fold function, which embodies a great deal of the features of a functional"},{"text":"programming language outlined above."},{"text":""}]}]